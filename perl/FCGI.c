/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.18 from the
 * contents of FCGI.xs. Do not edit this file, edit FCGI.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "FCGI.xs"
/* $Id: FCGI.XL,v 1.9 2002/11/11 13:51:20 skimo Exp $ */

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "fcgi_config.h"
#include "fcgiapp.h"
#include "fastcgi.h"

#ifndef FALSE
#define FALSE (0)
#endif

#ifndef TRUE
#define TRUE  (1)
#endif

#ifndef dTHX
#define dTHX
#endif

#ifndef INT2PTR
#define INT2PTR(a,b) ((a) (b))
#endif

#ifdef USE_SFIO
typedef struct
{
    Sfdisc_t	disc;
    FCGX_Stream	*stream;
} FCGI_Disc;

static ssize_t
sffcgiread(f, buf, n, disc)
Sfio_t*		f;      /* stream involved */
Void_t*		buf;    /* buffer to read into */
size_t		n;      /* number of bytes to read */
Sfdisc_t*	disc;   /* discipline */
{
    return FCGX_GetStr(buf, n, ((FCGI_Disc *)disc)->stream);
}

static ssize_t
sffcgiwrite(f, buf, n, disc)
Sfio_t*		f;      /* stream involved */
const Void_t*	buf;    /* buffer to read into */
size_t		n;      /* number of bytes to read */
Sfdisc_t*	disc;   /* discipline */
{
    n = FCGX_PutStr(buf, n, ((FCGI_Disc *)disc)->stream);
    FCGX_FFlush(((FCGI_Disc *)disc)->stream);
    return n;
}

Sfdisc_t *
sfdcnewfcgi(stream)
	FCGX_Stream *stream;
{
    FCGI_Disc*	disc;

    New(1000,disc,1,FCGI_Disc);
    if (!disc) return (Sfdisc_t *)disc;

    disc->disc.exceptf = (Sfexcept_f)NULL;
    disc->disc.seekf = (Sfseek_f)NULL;
    disc->disc.readf = sffcgiread;
    disc->disc.writef = sffcgiwrite;
    disc->stream = stream;
    return (Sfdisc_t *)disc;
}

Sfdisc_t *
sfdcdelfcgi(disc)
    Sfdisc_t*	disc;
{
    Safefree(disc);
    return 0;
}
#endif

#if defined(USE_LOCKING) && defined(USE_THREADS)
static perl_mutex   accept_mutex;
#endif

typedef struct FCGP_Request {
    int		    accepted;
    int		    bound;
    SV*		    svin;
    SV*		    svout;
    SV*		    sverr;
    GV*		    gv[3];
    HV*		    hvEnv;
    FCGX_Request*   requestPtr;
#ifdef USE_SFIO
    int		    sfcreated[3];
    IO*		    io[3];
#endif
} FCGP_Request;

static void FCGI_Finish(FCGP_Request* request);

static void 
FCGI_Flush(FCGP_Request* request)
{
    dTHX;

    if(!request->bound) {
	return;
	}
#ifdef USE_SFIO
    sfsync(IoOFP(GvIOp(request->gv[1])));
    sfsync(IoOFP(GvIOp(request->gv[2])));
#else
    FCGX_FFlush(INT2PTR(FCGX_Stream *, SvIV((SV*) SvRV(request->svout))));
    FCGX_FFlush(INT2PTR(FCGX_Stream *, SvIV((SV*) SvRV(request->sverr))));
#endif
}

static void
FCGI_UndoBinding(FCGP_Request* request)
{
    dTHX;

#ifdef USE_SFIO
    sfdcdelfcgi(sfdisc(IoIFP(request->io[0]), SF_POPDISC));
    sfdcdelfcgi(sfdisc(IoOFP(request->io[1]), SF_POPDISC));
    sfdcdelfcgi(sfdisc(IoOFP(request->io[2]), SF_POPDISC));
#else
#  ifdef USE_PERLIO
    sv_unmagic((SV *)GvIOp(request->gv[0]), 'q');
    sv_unmagic((SV *)GvIOp(request->gv[1]), 'q');
    sv_unmagic((SV *)GvIOp(request->gv[2]), 'q');
#  else
    sv_unmagic((SV *)request->gv[0], 'q');
    sv_unmagic((SV *)request->gv[1], 'q');
    sv_unmagic((SV *)request->gv[2], 'q');
#  endif
#endif
    request->bound = FALSE;
}

static void
FCGI_Bind(FCGP_Request* request)
{
    dTHX;

#ifdef USE_SFIO
    sfdisc(IoIFP(request->io[0]), sfdcnewfcgi(request->requestPtr->in));
    sfdisc(IoOFP(request->io[1]), sfdcnewfcgi(request->requestPtr->out));
    sfdisc(IoOFP(request->io[2]), sfdcnewfcgi(request->requestPtr->err));
#else
#  ifdef USE_PERLIO
    /* For tied filehandles, we apply tiedscalar magic to the IO
       slot of the GP rather than the GV itself. */

    if (!GvIOp(request->gv[1]))
	GvIOp(request->gv[1]) = newIO();
    if (!GvIOp(request->gv[2]))
	GvIOp(request->gv[2]) = newIO();
    if (!GvIOp(request->gv[0]))
	GvIOp(request->gv[0]) = newIO();

    sv_magic((SV *)GvIOp(request->gv[1]), request->svout, 'q', Nullch, 0);
    sv_magic((SV *)GvIOp(request->gv[2]), request->sverr, 'q', Nullch, 0);
    sv_magic((SV *)GvIOp(request->gv[0]), request->svin, 'q', Nullch, 0);
#  else
    sv_magic((SV *)request->gv[1], request->svout, 'q', Nullch, 0);
    sv_magic((SV *)request->gv[2], request->sverr, 'q', Nullch, 0);
    sv_magic((SV *)request->gv[0], request->svin, 'q', Nullch, 0);
#  endif
#endif
    request->bound = TRUE;
}

static void
populate_env(envp, hv)
char **envp;
HV *hv;
{
    int i;
    char *p, *p1;
    SV   *sv;
    dTHX;

    hv_clear(hv);
    for(i = 0; ; i++) {
	if((p = envp[i]) == NULL) {
	    break;
	}
	p1 = strchr(p, '=');
	assert(p1 != NULL);
	sv = newSVpv(p1 + 1, 0);
	/* call magic for this value ourselves */
	hv_store(hv, p, p1 - p, sv, 0);
	SvSETMAGIC(sv);
    }
}

static int
FCGI_IsFastCGI(FCGP_Request* request)
{
    static int isCGI = -1; /* -1: not checked; 0: FCGI; 1: CGI */

    if (request->requestPtr->listen_sock == FCGI_LISTENSOCK_FILENO) {
	if (isCGI == -1)
	    isCGI = FCGX_IsCGI();
	return !isCGI;
    }

    /* A explicit socket is being used -> assume FastCGI */
    return 1;
}

static int 
FCGI_Accept(FCGP_Request* request)
{
    dTHX;

    if (!FCGI_IsFastCGI(request)) {
	static int been_here = 0;

        /*
         * Not first call to FCGI_Accept and running as CGI means
         * application is done.
         */
	if (been_here)
	    return EOF;

	been_here = 1;
    } else {
#ifdef USE_SFIO
	int i;
#endif
	FCGX_Request *fcgx_req = request->requestPtr;
        int acceptResult;

	FCGI_Finish(request);
#if defined(USE_LOCKING) && defined(USE_THREADS)
	MUTEX_LOCK(&accept_mutex);
#endif
	acceptResult = FCGX_Accept_r(fcgx_req);
#if defined(USE_LOCKING) && defined(USE_THREADS)
	MUTEX_UNLOCK(&accept_mutex);
#endif
        if(acceptResult < 0) {
            return acceptResult;
        }

	populate_env(fcgx_req->envp, request->hvEnv);

#ifdef USE_SFIO
	for (i = 0; i < 3; ++i) {
	    request->io[i] = GvIOn(request->gv[i]);
	    if (!(i == 0 ? IoIFP(request->io[i]) 
			 : IoOFP(request->io[i]))) {
		IoIFP(request->io[i]) = sftmp(0);
		/*IoIFP(request->io[i]) = sfnew(NULL, NULL, SF_UNBOUND, 0, 
				     SF_STRING | (i ? SF_WRITE : SF_READ));*/
		if (i != 0) 
		    IoOFP(request->io[i]) = IoIFP(request->io[i]);
		request->sfcreated[i] = TRUE;
	    }
	}
#else
	if (!request->svout) {
	    newSVrv(request->svout = newSV(0), "FCGI::Stream");
	    newSVrv(request->sverr = newSV(0), "FCGI::Stream");
	    newSVrv(request->svin = newSV(0), "FCGI::Stream");
	}
	sv_setiv(SvRV(request->svout), INT2PTR(IV, fcgx_req->out));
	sv_setiv(SvRV(request->sverr), INT2PTR(IV, fcgx_req->err));
	sv_setiv(SvRV(request->svin), INT2PTR(IV, fcgx_req->in));
#endif
	FCGI_Bind(request);
	request->accepted = TRUE;
    }
    return 0;
}

static void 
FCGI_Finish(FCGP_Request* request)
{
#ifdef USE_SFIO
    int i;
#endif
    int was_bound;
    dTHX;

    if(!request->accepted) {
	return;
    }

    if (was_bound = request->bound) {
	FCGI_UndoBinding(request);
    }
#ifdef USE_SFIO
    for (i = 0; i < 3; ++i) {
	if (request->sfcreated[i]) {
	    sfclose(IoIFP(request->io[i]));
	    IoIFP(request->io[i]) = IoOFP(request->io[i]) = Nullfp;
	    request->sfcreated[i] = FALSE;
	}
    }
#endif
    if (was_bound)
	FCGX_Finish_r(request->requestPtr);
    else
	FCGX_Free(request->requestPtr, 1);
    request->accepted = FALSE;
}

static int 
FCGI_StartFilterData(FCGP_Request* request)
{
    return request->requestPtr->in ? 
	    FCGX_StartFilterData(request->requestPtr->in) : -1;
}

static FCGP_Request *
FCGI_Request(in, out, err, env, socket, flags)
    GV*	    in;
    GV*	    out;
    GV*	    err;
    HV*	    env;
    int	    socket;
    int	    flags;
{
    FCGX_Request* fcgx_req;
    FCGP_Request* req;

    Newz(551, fcgx_req, 1, FCGX_Request);
    FCGX_InitRequest(fcgx_req, socket, flags);
    Newz(551, req, 1, FCGP_Request);
    req->requestPtr = fcgx_req;
    SvREFCNT_inc(in);
    req->gv[0] = in;
    SvREFCNT_inc(out);
    req->gv[1] = out;
    SvREFCNT_inc(err);
    req->gv[2] = err;
    SvREFCNT_inc(env);
    req->hvEnv = env;

    return req;
}

static void
FCGI_Release_Request(FCGP_Request *req)
{
    SvREFCNT_dec(req->gv[0]);
    SvREFCNT_dec(req->gv[1]);
    SvREFCNT_dec(req->gv[2]);
    SvREFCNT_dec(req->hvEnv);
    FCGI_Finish(req);
    Safefree(req->requestPtr);
    Safefree(req);
}

static void
FCGI_Init()
{
#if defined(USE_LOCKING) && defined(USE_THREADS)
    dTHX;

    MUTEX_INIT(&accept_mutex);
#endif

    FCGX_Init();
}

typedef FCGX_Stream *	FCGI__Stream;
typedef FCGP_Request *	FCGI;
typedef	GV*		GLOBREF;
typedef	HV*		HASHREF;

#line 387 "FCGI.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 529 "FCGI.c"

XS_EUPXS(XS_FCGI_RequestX); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_FCGI_RequestX)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "in, out, err, env, socket, flags");
    {
	GLOBREF	in;
	GLOBREF	out;
	GLOBREF	err;
	HASHREF	env;
	int	socket = (int)SvIV(ST(4))
;
	int	flags = (int)SvIV(ST(5))
;
	SV *	RETVAL;

    if (SvROK(ST(0)) && isGV(SvRV(ST(0)))) {
	in = (GV*)SvRV(ST(0));
    } else
	croak("in is not a GLOB reference")
;

    if (SvROK(ST(1)) && isGV(SvRV(ST(1)))) {
	out = (GV*)SvRV(ST(1));
    } else
	croak("out is not a GLOB reference")
;

    if (SvROK(ST(2)) && isGV(SvRV(ST(2)))) {
	err = (GV*)SvRV(ST(2));
    } else
	croak("err is not a GLOB reference")
;

    if (SvROK(ST(3)) && SvTYPE(SvRV(ST(3))) == SVt_PVHV) {
	env = (HV*)SvRV(ST(3));
    } else
	croak("env is not a reference to a hash")
;
#line 393 "FCGI.xs"
    RETVAL = sv_setref_pv(newSV(0), "FCGI", 
		FCGI_Request(in, out, err, env, socket, flags));

#line 575 "FCGI.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_FCGI_OpenSocket); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_FCGI_OpenSocket)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "path, backlog");
    {
	char*	path = (char *)SvPV_nolen(ST(0))
;
	int	backlog = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;
#line 406 "FCGI.xs"
    RETVAL = FCGX_OpenSocket(path, backlog);
#line 598 "FCGI.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_FCGI_CloseSocket); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_FCGI_CloseSocket)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "socket");
    {
	int	socket = (int)SvIV(ST(0))
;
#line 416 "FCGI.xs"
    close(socket);
#line 616 "FCGI.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_FCGI_Accept); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_FCGI_Accept)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "request");
    {
	FCGI	request;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "FCGI")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"FCGI::Accept",
			"request", "FCGI")
;

	RETVAL = FCGI_Accept(request);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_FCGI_Finish); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_FCGI_Finish)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "request");
    {
	FCGI	request;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "FCGI")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"FCGI::Finish",
			"request", "FCGI")
;

	FCGI_Finish(request);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_FCGI_Flush); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_FCGI_Flush)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "request");
    {
	FCGI	request;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "FCGI")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"FCGI::Flush",
			"request", "FCGI")
;

	FCGI_Flush(request);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_FCGI_GetEnvironment); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_FCGI_GetEnvironment)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "request");
    {
	FCGI	request;
	HV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "FCGI")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"FCGI::GetEnvironment",
			"request", "FCGI")
;
#line 444 "FCGI.xs"
    RETVAL = request->hvEnv;

#line 722 "FCGI.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_FCGI_GetHandles); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_FCGI_GetHandles)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "request");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	FCGI	request;
#line 456 "FCGI.xs"
    int	    i;

#line 743 "FCGI.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "FCGI")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"FCGI::GetHandles",
			"request", "FCGI")
;
#line 459 "FCGI.xs"
    EXTEND(sp,3);
    for (i = 0; i < 3; ++i)
	PUSHs(sv_2mortal(newRV((SV *) request->gv[i])));
#line 758 "FCGI.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_FCGI_IsFastCGI); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_FCGI_IsFastCGI)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "request");
    {
	FCGI	request;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "FCGI")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"FCGI::IsFastCGI",
			"request", "FCGI")
;

	RETVAL = FCGI_IsFastCGI(request);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_FCGI_Detach); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_FCGI_Detach)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "request");
    {
	FCGI	request;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "FCGI")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"FCGI::Detach",
			"request", "FCGI")
;
#line 476 "FCGI.xs"
    if (request->accepted && request->bound)
	FCGI_UndoBinding(request);
#line 814 "FCGI.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_FCGI_Attach); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_FCGI_Attach)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "request");
    {
	FCGI	request;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "FCGI")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"FCGI::Attach",
			"request", "FCGI")
;
#line 486 "FCGI.xs"
    if (request->accepted && !request->bound)
	FCGI_Bind(request);
#line 841 "FCGI.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_FCGI_LastCall); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_FCGI_LastCall)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "request");
    {
	FCGI	request;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "FCGI")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"FCGI::LastCall",
			"request", "FCGI")
;
#line 496 "FCGI.xs"
    FCGX_ShutdownPending();
#line 867 "FCGI.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_FCGI_StartFilterData); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_FCGI_StartFilterData)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "request");
    {
	FCGI	request;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "FCGI")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"FCGI::StartFilterData",
			"request", "FCGI")
;

	RETVAL = FCGI_StartFilterData(request);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_FCGI_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_FCGI_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "request");
    {
	FCGI	request;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"FCGI::DESTROY",
			"request")
;
#line 510 "FCGI.xs"
    FCGI_Release_Request(request);
#line 921 "FCGI.c"
    }
    XSRETURN_EMPTY;
}

#ifndef USE_SFIO
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_FCGI__Stream_PRINT); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_FCGI__Stream_PRINT)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "stream, ...");
    {
	FCGI__Stream	stream;
#line 523 "FCGI.xs"
	int	n;

#line 941 "FCGI.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "FCGI::Stream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    stream = INT2PTR(FCGI__Stream,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"FCGI::Stream::PRINT",
			"stream", "FCGI::Stream")
;
#line 526 "FCGI.xs"
	for (n = 1; n < items; ++n) {
            STRLEN len;
            register char *tmps = (char *)SvPV(ST(n),len);
            FCGX_PutStr(tmps, len, stream);
	}
	if (SvTRUEx(perl_get_sv("|", FALSE))) 
	    FCGX_FFlush(stream);
#line 960 "FCGI.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_FCGI__Stream_WRITE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_FCGI__Stream_WRITE)
{
    dVAR; dXSARGS;
    if (items < 3)
       croak_xs_usage(cv,  "stream, bufsv, len, ...");
    {
	FCGI__Stream	stream;
	SV *	bufsv = ST(1)
;
	int	len = (int)SvIV(ST(2))
;
#line 541 "FCGI.xs"
	int	offset;
	char *	buf;
	STRLEN	blen;
	int	n;

#line 984 "FCGI.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "FCGI::Stream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    stream = INT2PTR(FCGI__Stream,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"FCGI::Stream::WRITE",
			"stream", "FCGI::Stream")
;
#line 547 "FCGI.xs"
	offset = (items == 4) ? (int)SvIV(ST(3)) : 0;
	buf = SvPV(bufsv, blen);
	if (offset < 0) offset += blen;
	if (len > blen - offset)
	    len = blen - offset;
	if (offset < 0 || offset >= blen ||
		(n = FCGX_PutStr(buf+offset, len, stream)) < 0) 
	    ST(0) = &PL_sv_undef;
	else {
	    ST(0) = sv_newmortal();
	    sv_setpvf(ST(0), "%c", n);
	}
#line 1010 "FCGI.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_FCGI__Stream_READ); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_FCGI__Stream_READ)
{
    dVAR; dXSARGS;
    if (items < 3)
       croak_xs_usage(cv,  "stream, bufsv, len, ...");
    {
	FCGI__Stream	stream;
	SV *	bufsv = ST(1)
;
	int	len = (int)SvIV(ST(2))
;
#line 567 "FCGI.xs"
	int	offset;
	char *	buf;

#line 1032 "FCGI.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "FCGI::Stream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    stream = INT2PTR(FCGI__Stream,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"FCGI::Stream::READ",
			"stream", "FCGI::Stream")
;
#line 571 "FCGI.xs"
	offset = (items == 4) ? (int)SvIV(ST(3)) : 0;
	if (! SvOK(bufsv))
	    sv_setpvn(bufsv, "", 0);
	buf = SvGROW(bufsv, len+offset+1);
	len = FCGX_GetStr(buf+offset, len, stream);
	SvCUR_set(bufsv, len+offset);
	*SvEND(bufsv) = '\0';
	(void)SvPOK_only(bufsv);
	SvSETMAGIC(bufsv);
	RETVAL = len;

#line 1057 "FCGI.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_FCGI__Stream_GETC); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_FCGI__Stream_GETC)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "stream");
    {
	FCGI__Stream	stream;
#line 590 "FCGI.xs"
	int	retval;

#line 1075 "FCGI.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "FCGI::Stream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    stream = INT2PTR(FCGI__Stream,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"FCGI::Stream::GETC",
			"stream", "FCGI::Stream")
;
#line 593 "FCGI.xs"
	if ((retval = FCGX_GetChar(stream)) != -1) {
	    ST(0) = sv_newmortal();
	    sv_setpvf(ST(0), "%c", retval);
	} else ST(0) = &PL_sv_undef;
#line 1092 "FCGI.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_FCGI__Stream_CLOSE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_FCGI__Stream_CLOSE)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "stream");
    {
	FCGI__Stream	stream;
	bool	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "FCGI::Stream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    stream = INT2PTR(FCGI__Stream,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"FCGI::Stream::CLOSE",
			"stream", "FCGI::Stream")
;
#line 606 "FCGI.xs"
	RETVAL = FCGX_FClose(stream) != -1;

#line 1120 "FCGI.c"
	ST(0) = sv_newmortal();
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}

#endif
#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_FCGI); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_FCGI)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        (void)newXSproto_portable("FCGI::RequestX", XS_FCGI_RequestX, file, "***$$$");
        (void)newXSproto_portable("FCGI::OpenSocket", XS_FCGI_OpenSocket, file, "$$");
        (void)newXSproto_portable("FCGI::CloseSocket", XS_FCGI_CloseSocket, file, "$");
        (void)newXSproto_portable("FCGI::Accept", XS_FCGI_Accept, file, "$");
        (void)newXSproto_portable("FCGI::Finish", XS_FCGI_Finish, file, "$");
        (void)newXSproto_portable("FCGI::Flush", XS_FCGI_Flush, file, "$");
        (void)newXSproto_portable("FCGI::GetEnvironment", XS_FCGI_GetEnvironment, file, "$");
        (void)newXSproto_portable("FCGI::GetHandles", XS_FCGI_GetHandles, file, "$");
        (void)newXSproto_portable("FCGI::IsFastCGI", XS_FCGI_IsFastCGI, file, "$");
        (void)newXSproto_portable("FCGI::Detach", XS_FCGI_Detach, file, "$");
        (void)newXSproto_portable("FCGI::Attach", XS_FCGI_Attach, file, "$");
        (void)newXSproto_portable("FCGI::LastCall", XS_FCGI_LastCall, file, "$");
        (void)newXSproto_portable("FCGI::StartFilterData", XS_FCGI_StartFilterData, file, "$");
        newXS("FCGI::DESTROY", XS_FCGI_DESTROY, file);
#if XSubPPtmpAAAA
        newXS("FCGI::Stream::PRINT", XS_FCGI__Stream_PRINT, file);
        newXS("FCGI::Stream::WRITE", XS_FCGI__Stream_WRITE, file);
        newXS("FCGI::Stream::READ", XS_FCGI__Stream_READ, file);
        newXS("FCGI::Stream::GETC", XS_FCGI__Stream_GETC, file);
        newXS("FCGI::Stream::CLOSE", XS_FCGI__Stream_CLOSE, file);
#endif

    /* Initialisation Section */

#line 380 "FCGI.xs"
    FCGI_Init();

#if XSubPPtmpAAAA
#endif
#line 1177 "FCGI.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

